#!/bin/bash

# Q&D script to tweet voter info to a random sequence of all the states, separated
# by random intervals, but no less than 10 minutes.  The cycle fits into ~24hrs.
# Meant to run in the background over the course of a day.

# Suppress some actions when debugging (-x)
exec=
[[ "$-" =~ .*x.* ]] && exec=:

usage() {
	echo "Usage:
$0 -h
$0 [-s state] [-q number-of-tweets(min 4)] [-w time-period(max 86400 sec)] campaign"
}

while getopts hs:q:w: option; do
	case $option in
	h) usage
		exit 0
		;;
	s) state="$OPTARG"
		;;
	q) quanta="$OPTARG"
		;;
	w) waking_hrs="$OPTARG"
		;;
	?) usage
		exit 1
	esac
done

args=("$@")
OPTIND=$(($OPTIND - 1))
campaign="${args[$OPTIND]}"
[ -n "$campaign" ] || { usage; exit 1; }

# Be careful to quote multi-word names into the array
if [ -z "$state" ]; then
	state_gen="
import campaign
import render
render.all_states(campaign.campaigns['"$campaign"'])
"
	eval state_seq=( `python -c "$state_gen" | shuf` )
	place_label_sing="State"
	place_label_plu="States"
else
	cities_gen="
import campaign
import render
render.all_cities(campaign.campaigns['"$campaign"'], '""$state""')
"
	eval state_seq=( `python -c "$cities_gen" | shuf` )
	place_label_sing="Step"
	place_label_plu="Steps"
fi

# Calibration: minimum 10 min. interval.  Set of len(state_seq) intervals adds to "Elapsed:"
# hours, so all states will be tweeted within "waking hours" (approx. 16 hrs., e.g. 6AM-10PM).
# This algorithm applies for states as well as cities within a state.
base_wait=600
[ "$quanta" -ge 4 -a "$quanta" -le ${#state_seq[@]} ] 2>- || quanta=${#state_seq[@]}
[ "$waking_hrs" -ge 0 -a "$waking_hrs" -le 86400 ] 2>- || waking_hrs=$((16 * 60 * 60))  # sec.

# We have one base_wait interval, then ($quanta - 2) wait intervals occurring between states
delta=`exec 2>-; echo $(( ($waking_hrs - (($quanta - 2) * $base_wait)) / (($quanta - 2)**2 / 2) ))`
[ "$delta" -ge 0 ] 2>- || delta=0
echo "quanta: $quanta, delta: $delta"
interval_seq=( `count=1; time=$base_wait;
		while [ $count -lt $quanta ]; do
			echo $time; time=$(($time + $delta)); count=$(($count + 1));
		done | shuf` )
interval_seq=( ${interval_seq[@]} 0 )	# Terminate interval list
echo "Elapsed:" $(((`echo ${interval_seq[*]} | sed 's/ /+/g'`) / 60)) "min."

# Print schedule of tweets
i=0
echo -n "$place_label_plu/intervals: "
while [ -n "${state_seq[$i]}" -a -n "${interval_seq[$i]}" ]; do
	if [ -z "$state" ]; then
		echo -n "${state_seq[$i]}/${interval_seq[$i]}"
	else
		echo -n "$(($i + 1))/${interval_seq[$i]}"
	fi
	echo -n " "
	i=$(($i + 1))
done

# Enter tweeting loop
# NOTE: For this algorithm, a "state" will contain a city name if the script was invoked with -s.
i=0
while [ -n "${state_seq[$i]}" -a -n "${interval_seq[$i]}" ]; do
	echo
	if [ -z "$state" ]; then
		echo "$place_label_sing $(($i + 1)): ${state_seq[$i]}, interval ${interval_seq[$i]}"
	else
		echo "$place_label_sing $(($i + 1)), interval ${interval_seq[$i]}"
	fi

	# For cities in a state, always tweet the same state
	[ -z "$state" ] && place="${state_seq[$i]}" || place="$state"
	$exec python voterinfo.py $campaign "$place"
	$exec sleep ${interval_seq[$i]}
	i=$(($i + 1))
done
